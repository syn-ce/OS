import java.util.*;

public class Shunter {
    private Log log = new Log(new String[]{"Aktion", "Waggon", "von", "nach", "Zuggleis", "Rangiergleis", "Abstellgleis"}, new boolean[]{true, true, false, false, true, true, true});
    private Rail parkingRail;
    private Rail switchingRail;
    private Rail trainRail;
    private Integer[] wagonValues;
    private Integer[] uniqueWagonValuesAscending;
    private boolean print = false;

    public Shunter(Rail parkingRail, Rail switchingRail, Rail trainRail) {
        this.parkingRail = parkingRail;
        this.switchingRail = switchingRail;
        this.trainRail = trainRail;
        wagonValues = parkingRail.getWagonValues();
        Arrays.sort(wagonValues);
        initialiseUniqueValuesAscending();
    }

    public void printUniqueValuesAscending() {
        System.out.println(Arrays.toString(uniqueWagonValuesAscending));
    }

    private void initialiseUniqueValuesAscending() {
        List<Integer> helper = new ArrayList<>(new HashSet<>(Arrays.asList(wagonValues.clone())));
        uniqueWagonValuesAscending = new Integer[helper.size()];
        for (int i = 0; i < helper.size(); i++) {
            int num = helper.get(i);
            uniqueWagonValuesAscending[i] = num;
        }
        Arrays.sort(uniqueWagonValuesAscending);
    }

    private void moveWagon(Rail from, Rail to) {
        int waggon = from.removeWagon();
        to.addWagon(waggon);
        log.addAction(String.valueOf(waggon), from.getName(), to.getName(), trainRail.getWagonsString(), switchingRail.getReverseWagonString(), parkingRail.getReverseWagonString());
    }

    // nodeList is the list of node names in the correct order, INCLUDING obsolete start-node (this makes indexing a
    // bit easier; note that the first note will never be looked at, since there will never be any value, let alone the
    // smallest, in the switchingRail before the first movement):
    // [LP3, LP4, RP6, RP8, RP9, LP14, LP16] (note that in every case, there will be another value; in this case, there
    // might be wagons with value 18 - however, once we've removed the second-to-last "layer" of nodes (here 16), it
    // won't matter where we start to remove the last one, it will always be optimal
    public void shuntNew(String[] nodeList) {
        for (int i = 0; i < uniqueWagonValuesAscending.length; i++) {
            int wagonNr = uniqueWagonValuesAscending[i];
            // get positions of that wagonNr on both rails
            int paPos = parkingRail.getSmallestPosOfNr(wagonNr);
            int swPos = switchingRail.getSmallestPosOfNr(wagonNr);

            if (swPos == -1 || paPos == -1) {  // the number is only present on one of the rails: there is no decision to be made
                if (swPos == -1) {  // value is on parkingRail -> remove all value from parkingRail
                    moveAllNrsFromTo(wagonNr, parkingRail, switchingRail);
                } else {  // value is on switchingRail -> remove all value from switchingRail
                    moveAllNrsFromTo(wagonNr, switchingRail, parkingRail);
                }
            } else {    // wagonNr is present on both rails -> need to consult the list generated by the graph
                String nodeName = "L";  // TODO: fix indexing; and clear this up -> note that for the very last removal,
                // TODO: the starting point does not matter, since there is only one value left -> removal in any order
                //  will suffice for optimal solution (so this is not that important, but still, it's not very nice-looking, is it?)
                if (i < nodeList.length) {
                    nodeName = nodeList[i];
                }
                if (nodeName.charAt(0) == 'L') {    // look to left (switchingRail) first
                    moveAllNrsFromTo(wagonNr, switchingRail, parkingRail);
                    moveAllNrsFromTo(wagonNr, parkingRail, switchingRail);
                } else {  // nodeName.charAt(0) == 'R', look to right (parkingRail) first
                    moveAllNrsFromTo(wagonNr, parkingRail, switchingRail);
                    moveAllNrsFromTo(wagonNr, switchingRail, parkingRail);
                }
            }
        }
        if (print) log.print();
    }

    public void shunt2() {
        for (int i = 0; i < wagonValues.length; i++) {
//            // get Rail on which wagon with value is closest
            int wagonNr = wagonValues[i];
            int paPos = parkingRail.getSmallestPosOfNr(wagonNr);
            int swPos = switchingRail.getSmallestPosOfNr(wagonNr);

            if (swPos == -1 || (paPos != -1 && paPos < swPos)) {
                while (parkingRail.getNextWagon() != wagonNr) {
                    moveWagon(parkingRail, switchingRail);
                }
                moveWagon(parkingRail, trainRail);
            } else {
                while (switchingRail.getNextWagon() != wagonNr) {
                    moveWagon(switchingRail, parkingRail);
                }
                moveWagon(switchingRail, trainRail);
            }
        }
        if (print) log.print();
    }

    public void shunt2equal() {
        for (int i = 0; i < wagonValues.length; i++) {
//            // get Rail on which wagon with value is closest
            int wagonNr = wagonValues[i];
            int paPos = parkingRail.getSmallestPosOfNr(wagonNr);
            int swPos = switchingRail.getSmallestPosOfNr(wagonNr);

            if (swPos == -1 || (paPos != -1 && paPos <= swPos)) {
                while (parkingRail.getNextWagon() != wagonNr) {
                    moveWagon(parkingRail, switchingRail);
                }
                moveWagon(parkingRail, trainRail);
            } else {
                while (switchingRail.getNextWagon() != wagonNr) {
                    moveWagon(switchingRail, parkingRail);
                }
                moveWagon(switchingRail, trainRail);
            }
        }
        if (print) log.print();
    }

    /**
     * This function will move all wagons from the from-Rail to the to-Rail until there are no more wagons with the
     * specified value in the from-Rail. All wagons with value == nr will be moved from the from-Rail onto the
     * train-Rail instead.
     *
     * @param wagonNr Value of wagons to be moved to trainRail.
     */
    private void moveAllNrsFromTo(int wagonNr, Rail from, Rail to) {
        while (from.getSmallestPosOfNr(wagonNr) != -1) {
            while (from.getNextWagon() != wagonNr) {
                moveWagon(from, to);
            }
            moveWagon(from, trainRail);
        }
    }

    public int getLogSize() {
        return log.getSize();
    }

}
