import java.util.*;

public class Shunter {
    private Log log = new Log(new String[]{"Aktion", "Waggon", "von", "nach", "Zuggleis", "Rangiergleis", "Abstellgleis"}, new boolean[]{true, true, false, false, true, true, true});
    private Rail parkingRail;
    private Rail switchingRail;
    private Rail trainRail;
    private Integer[] wagonValues;
    private Integer[] uniqueWagonValuesAscending;
    private boolean print = false;

    public Shunter(Rail parkingRail, Rail switchingRail, Rail trainRail) {
        this.parkingRail = parkingRail;
        this.switchingRail = switchingRail;
        this.trainRail = trainRail;
        wagonValues = parkingRail.getWagonValues();
        Arrays.sort(wagonValues);
        initialiseUniqueValuesAscending();
    }

    public void printUniqueValuesAscending() {
        System.out.println(Arrays.toString(uniqueWagonValuesAscending));
    }
    private void initialiseUniqueValuesAscending() {
        List<Integer> helper = new ArrayList<>(new HashSet<>(Arrays.asList(wagonValues.clone())));
        uniqueWagonValuesAscending = new Integer[helper.size()];
        for (int i = 0; i < helper.size(); i++) {
            int num = helper.get(i);
            uniqueWagonValuesAscending[i] = num;
        }
        Arrays.sort(uniqueWagonValuesAscending);
    }

    private void switchWagon(Rail from, Rail to) {
        int waggon = from.removeWagon();
        to.addWagon(waggon);
//        String pRail = new StringBuilder(parkingRail.getWagonsString()).reverse().toString(); // need to reverse this string bc all the trains' backs are facing inwards, whatever
//        String sRail = new StringBuilder(switchingRail.getWagonsString()).reverse().toString(); // need to reverse this string bc all the trains' backs are facing inwards, whatever
        log.addAction(waggon, from.getName(), to.getName(), trainRail.getWagonsString(), switchingRail.getReverseWagonString(), parkingRail.getReverseWagonString());
    }

    // nodeList is the list of node names in the correct order, INCLUDING obsolete start-node (this makes indexing a
    // bit easier; note that the first note will never be looked at, since there will never be any value, let alone the
    // smallest, in the switchingRail before the first movement):
    // [start, LP3, LP4, RP6, RP8, RP9, LP14, LP16]
    public int shuntNew(String[] nodeList) {
        for (int i = 0; i < uniqueWagonValuesAscending.length; i++) {
            // get current wagonNr
            int wagonNr = uniqueWagonValuesAscending[i];
            // get positions of that wagonNr on both rails
            int paPos = parkingRail.getSmallestPosOfNr(wagonNr);
            int swPos = switchingRail.getSmallestPosOfNr(wagonNr);

            if (swPos == -1 || paPos == -1) {  // the number is only present on one of the rails: there is no decision to be made
                if (swPos == -1) {  // value is on parkingRail -> remove all value from parkingRail
                    moveAllNrsFromTo(wagonNr, parkingRail, switchingRail);
                } else {  // value is on switchingRail -> remove all value from switchingRail
                    moveAllNrsFromTo(wagonNr, switchingRail, parkingRail);
                }

            } else {    // wagonNr is present on both rails -> need to consult the list generated by the graph
                String nodeName = "L";  // TODO: fix indexing; and clear this up -> note that for the very last removal,
                // TODO: the starting point does not matter, since there is only one value left -> removal in any order
                //  will suffice for optimal solution
                if (i < nodeList.length) {  // is this condition always true? -> should be...
                    nodeName = nodeList[i];    // error was here; looked at nodeList[i] instead of nodeList[i+1] -> implement check for whether number of node matches current wagonNr!
                }
                // actually quite a funny error, since whether the graph decides for RP or LP when there is only one value is somewhat arbitrary, but in this instance it was probably shifting because of some storage shenanigans -> anyway, good it happened right now and not later!
                if (print) System.out.println("Consulting the graph at iteration " + i + ". Decided for " + nodeName);
                if (print) System.out.println("WagonNr = " + wagonNr);
                if (nodeName.charAt(0) == 'L') {    // look to left (switchingRail) first
                    moveAllNrsFromTo(wagonNr, switchingRail, parkingRail);
                    moveAllNrsFromTo(wagonNr, parkingRail, switchingRail);
                } else {  // nodeName.charAt(0) == 'R', look to right (parkingRail) first
                    moveAllNrsFromTo(wagonNr, parkingRail, switchingRail);
                    moveAllNrsFromTo(wagonNr, switchingRail, parkingRail);
                }
            }
        }
        if (print) log.print();
        return getLogSize();
    }

    public int shunt2() {
        for (int i = 0; i < wagonValues.length; i++) {
//            // get Rail on which wagon with value is closest
            int wagonNr = wagonValues[i];
            int paPos = parkingRail.getSmallestPosOfNr(wagonNr);
            int swPos = switchingRail.getSmallestPosOfNr(wagonNr);

            if (swPos == -1 || (paPos != -1 && paPos < swPos)) {
                while (parkingRail.getNextWagon() != wagonNr) {
                    switchWagon(parkingRail, switchingRail);
                }
                switchWagon(parkingRail, trainRail);
            } else {
                while (switchingRail.getNextWagon() != wagonNr) {
                    switchWagon(switchingRail, parkingRail);
                }
                switchWagon(switchingRail, trainRail);
            }
        }
        if (print) log.print();
        return getLogSize();
    }

    public int shunt2equal() {
        for (int i = 0; i < wagonValues.length; i++) {
//            // get Rail on which wagon with value is closest
            int wagonNr = wagonValues[i];
            int paPos = parkingRail.getSmallestPosOfNr(wagonNr);
            int swPos = switchingRail.getSmallestPosOfNr(wagonNr);

            if (swPos == -1 || (paPos != -1 && paPos <= swPos)) {
                while (parkingRail.getNextWagon() != wagonNr) {
                    switchWagon(parkingRail, switchingRail);
                }
                switchWagon(parkingRail, trainRail);
            } else {
                while (switchingRail.getNextWagon() != wagonNr) {
                    switchWagon(switchingRail, parkingRail);
                }
                switchWagon(switchingRail, trainRail);
            }
        }
        if (print) log.print();
        return getLogSize();
    }
    /**
     * This function will move all wagons from the from-Rail to the to-Rail until there are no more wagons with the
     * specified value in the from-Rail. All wagons with value == nr will be moved from the from-Rail onto the
     * train-Rail instead.
     *
     * @param wagonNr Value of wagons to be moved to trainRail.
     */
    private void moveAllNrsFromTo(int wagonNr, Rail from, Rail to) {
        while (from.getSmallestPosOfNr(wagonNr) != -1) {
            while (from.getNextWagon() != wagonNr) {
                switchWagon(from, to);
            }
            switchWagon(from, trainRail);
        }
    }

    public int getLogSize() {
        return log.getSize();
    }

}
