import java.util.Arrays;
import java.util.Collections;
import java.util.HashSet;
import java.util.Set;

public class Shunter {
    private Log log = new Log(new String[]{"Aktion", "Waggon", "von", "nach", "Zuggleis", "Rangiergleis", "Abstellgleis"}, new boolean[]{true, true, false, false, true, true, true});
    private Rail parkingRail;
    private Rail switchingRail;
    private Rail trainRail;
    private Integer[] wagonValues;
    private Integer[] uniqueWagonValuesAscending;

    public Shunter(Rail parkingRail, Rail switchingRail, Rail trainRail) {
        this.parkingRail = parkingRail;
        this.switchingRail = switchingRail;
        this.trainRail = trainRail;
        wagonValues = parkingRail.getWagonValues();
        Arrays.sort(wagonValues);
        initialiseUniqueValuesAscending();
    }

    private void initialiseUniqueValuesAscending() {
        Set<Integer> helper = new HashSet<>(Arrays.asList(wagonValues));
        uniqueWagonValuesAscending = helper.toArray(new Integer[0]);
        Arrays.sort(uniqueWagonValuesAscending);
    }

    private void switchWagon(Rail from, Rail to) {
        int waggon = from.removeWagon();
        to.addWagon(waggon);
//        String pRail = new StringBuilder(parkingRail.getWagonsString()).reverse().toString(); // need to reverse this string bc all the trains' backs are facing inwards, whatever
//        String sRail = new StringBuilder(switchingRail.getWagonsString()).reverse().toString(); // need to reverse this string bc all the trains' backs are facing inwards, whatever
        log.addAction(waggon, from.getName(), to.getName(), trainRail.getWagonsString(), switchingRail.getReverseWagonString(), parkingRail.getReverseWagonString());
    }

    // nodeList is the list of node names in the correct order, INCLUDING obsolete start-node (this makes indexing a
    // bit easier; note that the first note will never be looked at, since there will never be any value, let alone the
    // smallest, in the switchingRail before the first movement):
    // [start, LP3, LP4, RP6, RP8, RP9, LP14, LP16]
    public void shuntNew(String[] nodeList) {
        for (int i = 0; i < uniqueWagonValuesAscending.length; i++) {
            // get current wagonNr
            int wagonNr = uniqueWagonValuesAscending[i];
            // get positions of that wagonNr on both rails
            int paPos = parkingRail.getSmallestPosOfNr(wagonNr);
            int swPos = switchingRail.getSmallestPosOfNr(wagonNr);

            if (swPos == -1 || paPos == -1) {  // the number is only present on one of the rails: there is no decision to be made
                if (swPos == -1) {  // value is on parkingRail -> remove all value from parkingRail
                    while (parkingRail.getSmallestPosOfNr(wagonNr) != -1) {
                        while (parkingRail.getNextWagon() != wagonNr) {
                            switchWagon(parkingRail, switchingRail);
                        }
                        switchWagon(parkingRail, trainRail);
                    }
                } else {  // value is on switchingRail -> remove all value from switchingRail
                    while (switchingRail.getSmallestPosOfNr(wagonNr) != -1) {
                        while (switchingRail.getNextWagon() != wagonNr) {
                            switchWagon(switchingRail, parkingRail);
                        }
                        switchWagon(switchingRail, trainRail);
                    }
                }

            } else {    // wagonNr is present on both rails -> need to consult the list generated by the graph
                String nodeName = nodeList[i];
                if (nodeName.charAt(0) == 'L') {    // look to left (switchingRail) first
                    while (switchingRail.getSmallestPosOfNr(wagonNr) != -1) {
                        while (switchingRail.getNextWagon() != wagonNr) {
                            switchWagon(switchingRail, parkingRail);
                        }
                        switchWagon(switchingRail, trainRail);
                    }
                    while (parkingRail.getSmallestPosOfNr(wagonNr) != -1) {
                        while (parkingRail.getNextWagon() != wagonNr) {
                            switchWagon(parkingRail, switchingRail);
                        }
                        switchWagon(parkingRail, trainRail);
                    }
                } else {  // nodeName.charAt(0) == 'R', look to right (parkingRail) first
                    while (parkingRail.getSmallestPosOfNr(wagonNr) != -1) {
                        while (parkingRail.getNextWagon() != wagonNr) {
                            switchWagon(parkingRail, switchingRail);
                        }
                        switchWagon(parkingRail, trainRail);
                    }
                    while (switchingRail.getSmallestPosOfNr(wagonNr) != -1) {
                        while (switchingRail.getNextWagon() != wagonNr) {
                            switchWagon(switchingRail, parkingRail);
                        }
                        switchWagon(switchingRail, trainRail);
                    }
                }
            }
        }
        log.print();
    }

    /**
     * This function will move all wagons from the from-Rail to the to-Rail until there are no more wagons with the
     * specified value in the from-Rail. All wagons with value == nr will be moved from the from-Rail onto the
     * train-Rail instead.
     * @param wagonNr Value of wagons to be moved to trainRail.
     */
    private void moveAllNrsFromTo(int wagonNr, Rail from, Rail to) {
        while (from.getSmallestPosOfNr(wagonNr) != -1) {
            while (from.getNextWagon() != wagonNr) {
                switchWagon(from, to);
            }
            switchWagon(from, trainRail);
        }
    }
    public int getLogSize() {
        return log.getSize();
    }

}
